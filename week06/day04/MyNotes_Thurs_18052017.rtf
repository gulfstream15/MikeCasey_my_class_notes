{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red34\green79\blue188;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww14860\viewh9660\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs28 \cf0 Week06 Day04\

\b0\fs24 \
A game class should know the logic of a game and can shift between different games by delegating the rules to a Rules class. \
\
Keep to the SOLID rules:\
\
SOLID - (I missed this).\
\
Understand how to compose objects using interfaces:\
\
Single responsibility: classes should do one thing only\
Open-closed: Open for extension, closed for modification\
Liskov: Substitute subclass for superclass without breaking it.\
Interface segment: lots of small interfaces > 1 big one\
Dependency: High level classes should not depend on low level ones - should depend on interface.\
\
You really should try to keep to the SOLID principles if possible. \
\
Card Game development\
\
top down and bottom up development e.g start with card class => bottom up\
\
Objectives \
\
\pard\tx220\tx720\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	\'95	}Know what the template pattern is\
{\listtext	\'95	}Understand how the template pattern helps us obey the open-closed principle\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
The pattern is the typicalDay() method in that we can enable overriding elsewhere. The template allows us to customise our code. \
\
See Bear.java - the template is the typicalDay() method - a mixture of concrete and abstract classes. \
This is used in android development e.g. onCreate(), onRefresh.\
\
in GrizzlyBear class:\
\
\
@Override\
  public void wakeUp() \{\
    super.wakeUp();\
    System.out.println("Yawwwwn");\
  \}\
\
we are extending the super class by having this method. This is respecting the open-closed principle of SOLID (see second point). \
\
Enums\
\
Know what an enum is\
Know how to use an enum\
\
Exceptions\
\
know what exceptions are used for\
understand when to throw your exceptions\
be able to write and handle exceptions\
\
For a large system it is likely that the the exception message goes to a file.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1 \cf1 \cb2 \CocoaLigature0 /Users/user/Desktop/CodeClan/Training/week06/day04/exceptions/try_catch_start_code\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \CocoaLigature1 \
In run method of ExampleTryCatch:\
\
\
public void run()\{\
    setup();\
    // Original code - ok \
    // Pet found = shop.findPetByName("Meowingtons");\
    // This next line will fail as null treated as a String\
    try \{\
      Pet found = shop.findPetByName(null);\
      System.out.println("Found pet: " + found.getName());\
    \}\
    catch(NullStringException ex) \{\
      // ex.PrintStackTrace();\
      System.out.println("Exception Message");\
      System.out.println(ex.getMessage());\
    \}\
    finally \{\
      System.out.println("and finally...");\
      System.out.println("I'm done");\
    \}\
  \} \
 \
\'91finally\'92 code still gets executed even when an exception called. An example of its usage is to send off a message to a server once an exception is thrown i.e. a log file.\
\
Advanced Testing - Objectives\
\
Know what doubles are \
Be able to write tests using doubles\
\
unit testing really should focus on one method or one class - any more than that and it is an integration. The FakeDice class is called a test double as you are testing code with something that mimics a fail. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1 \cf1 \cb2 \CocoaLigature0 /Users/user/Desktop/CodeClan/Training/week06/day04/start_code\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \CocoaLigature1 \
Java has inbuilt functionality called mojito:\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "http://mvnrepository.com/artifact/org.mockito/mockito-all/1.10.19"}}{\fldrslt \cf0 http://mvnrepository.com/artifact/org.mockito/mockito-all/1.10.19}}\
\
copy the jar file to the ~/junit directory\
\
in the .zshrc add this the PATH i.e.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1 \cf1 \cb2 \CocoaLigature0 export CLASSPATH="$CLASSPATH:$JUNIT_HOME/junit-4.12.jar:$JUNIT_HOME/hamcrest-core-1.3.jar:$JUNIT_HOME/mockito-all-1.10.19.jar"
\f0 \cf0 \cb1 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
import static org.junit.Assert.*;\
import org.junit.*;\
import org.mockito.*;\
import static org.mockito.Mockito.*;\
\
public class GameTest \{\
\
  Game game;\
  // Game failGame;\
  Rollable dice;\
  // Rollable failDice;\
  \
  @Before \
  public void before()\{\
    // Here we now have the functionality to\
    // test the dice and game\
    // dice = new FakeDice(6);\
    dice = mock(Rollable.class);\
    // failDice = new FakeDice(1);\
    game = new Game(dice);\
    // failGame = new Game(failGame);\
  \}\
\
  @Test\
  public void testTakeTurn()\{\
    when(dice.roll().thenReturn(3));\
    boolean result = game.nextTurn();\
    assertEquals(true, result);\
  \}\
  \
  @Test\
  public void testFailingTurn()\{\
    when(dice.roll().thenReturn(1));\
    boolean result = game.nextTurn();\
    assertEquals(false, result);\
  \}\
\
\}\
\
\
public class FakeDice implements Rollable \{\
\
  // int numberOfSides;\
  int rollResult;\
\
  // We don't need the number of sides any more\
  // we have the result and that is enough\
  // public FakeDice(int numberOfSides, int rollResult) \{\
    // this.numberOfSides = numberOfSides;\
  public FakeDice(int rollResult) \{\
    this.rollResult = rollResult;\
  \}\
\
  public int roll() \{\
    return this.rollResult;\
  \}\
\
\}\
}